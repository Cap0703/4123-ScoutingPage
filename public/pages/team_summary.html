<!doctype html>
<html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Team Summary</title>
<link rel="stylesheet" href="/css/style.css"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
.charts-row {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
}
.chart-container {
  flex: 1;
  min-width: 0;
}
.chart-container .card {
  margin: 0;
  height: 400px;
  display: flex;
  flex-direction: column;
}
.chart-container canvas {
  flex: 1;
  min-height: 0;
}
@media (max-width: 768px) {
  .charts-row {
    flex-direction: column;
  }
}
.team-info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
}

.info-item {
  padding: 8px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

.team-stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.stat-item {
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  text-align: center;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #d4af37;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

.robot-image-centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.robot-image-centered h3 {
  width: 100%;
  text-align: center;
  margin-bottom: 15px;
}

.robot-image-centered img {
  display: block;
  margin: 0 auto;
  max-width: 100%;
  max-height: 400px;
}
.match-type-stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.match-type-stat-item {
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  text-align: center;
}

.match-type-stat-value {
  font-size: 1.3rem;
  font-weight: bold;
  color: #4ecdc4;
}

.match-type-stat-label {
  font-size: 0.85rem;
  opacity: 0.8;
  margin-bottom: 5px;
}

.match-type-stat-count {
  font-size: 0.8rem;
  opacity: 0.7;
}

.trendline-options {
  margin: 15px 0;
  padding: 10px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
}

.trendline-options label {
  margin-right: 15px;
}

.trendline-checkbox {
  margin-right: 5px;
}

.trendline-type {
  margin-left: 15px;
  display: none;
}

.trendline-options.active .trendline-type {
  display: inline-block;
}

.chart-with-trendline {
  position: relative;
}

.trendline-equation {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  color: white;
}
</style>
<style>
  /* Event History Toggle and Cards */
  .event-history-toggle {
    margin: 15px 0;
    text-align: center;
  }
  
  .event-history-container {
    display: none;
    position: fixed;
    left: 0;
    top: 0;
    width: 350px;
    height: 100vh;
    overflow-y: auto;
    background-color: rgba(40, 40, 40, 0.95);
    padding: 20px;
    z-index: 1000;
    box-shadow: 3px 0 10px rgba(0, 0, 0, 0.3);
  }
  
  .event-history-container.open {
    display: block;
  }
  
  .event-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .event-name {
    font-weight: bold;
    color: var(--gold);
  }
  
  .event-record {
    font-size: 0.9rem;
    background-color: rgba(255, 255, 255, 0.1);
    padding: 3px 8px;
    border-radius: 12px;
  }
  
  .match-breakdown {
    margin-top: 10px;
  }
  
  .match-item {
    padding: 8px;
    margin-bottom: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    font-size: 0.85rem;
  }
  
  .match-win {
    border-left: 3px solid #00ff6a;
  }
  
  .match-loss {
    border-left: 3px solid #ff1900;
  }
  
  .match-tie {
    border-left: 3px solid #f39c12;
  }
  
  .close-event-history {
    position: absolute;
    top: 10px;
    right: 15px;
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
  }
  
  .event-history-title {
    text-align: center;
    margin-bottom: 20px;
    color: var(--gold);
  }
  
  /* Adjust main content when event history is open */
  body.event-history-open .container {
    margin-left: 370px;
    transition: margin-left 0.3s ease;
  }

  /* Event History Toggle and Cards */
.event-history-toggle {
  margin: 15px 0;
  text-align: center;
}

.event-history-container {
  display: none;
  position: fixed;
  left: 0;
  top: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  background-color: rgba(40, 40, 40, 0.95);
  padding: 20px;
  z-index: 1000;
  box-shadow: 3px 0 10px rgba(0, 0, 0, 0.3);
}

.match-breakdown {
  margin-top: 10px;
}

.event-history-title {
  text-align: center;
  margin-bottom: 20px;
  color: var(--gold);
}

body.event-history-open .container {
  margin-left: 370px;
  transition: margin-left 0.3s ease;
}
  .event-history-toggle {
    margin: 15px 0;
    text-align: center;
  }

  .event-history-container {
    display: none;
    position: fixed;
    left: 0;
    top: 0;
    width: 350px;
    height: 100vh;
    overflow-y: auto;
    background-color: var(--bg);
    padding: 20px;
    z-index: 1000;
    box-shadow: 3px 0 10px rgba(0, 0, 0, 0.3);
  }

  .event-history-container.open {
    display: block;
  }

  .event-card {
    background-color: #727272;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    border-left: 4px solid #ccc;
  }

  .event-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.1);
  }

  .event-name {
    font-weight: bold;
    color: var(--gold);
    font-size: 1.1rem;
  }

  .event-record {
    font-size: 0.9rem;
    background-color: rgba(255, 255, 255, 0.1);
    padding: 5px 10px;
    border-radius: 12px;
    color: var(--text);
  }

  .match-breakdown {
    margin-top: 10px;
  }

  .match-item {
    background-color: rgb(149, 149, 149);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    
    transition: transform 0.2s;
  }

    .match-item.loss {
    border-left: 4px solid #fd0000;
  }
    .match-item.win {
    border-left: 4px solid #00ff0d;
  }
      .match-item.tie {
    border-left: 4px solid #fdad00;
  }

  .match-item:hover {
    transform: translateY(-3px);
  }

  .match-upcoming {
    border-left-color: var(--blue);
  }

  .alliance-teams {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-size: 0.9rem;
  }

  .alliance {
    flex: 1;
    padding: 5px;
    border-radius: 4px;
    text-align: center;
  }

  .alliance.red {
    background-color: rgb(192, 80, 67);
    color: var(--red);
  }

  .alliance.blue {
    background-color: rgb(52, 152, 219);
    color: var(--blue);
  }

  .team-highlight {
    color:rgb(246, 255, 0);
    font-weight: bold;
    text-decoration: underline;
  }

  .score {
    font-weight: bold;
    font-size: 1.1em;
    text-align: center;
    margin: 8px 0;
  }

  .red-score {
    color: rgb(175, 44, 30);
  }

  .blue-score {
    color: rgb(52, 152, 219);
  }

  .match-result {
    text-align: center;
    font-weight: bold;
    margin-top: 8px;
    padding-top: 5px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .result-win {
    color: rgb(12, 161, 74);
  }

  .result-loss {
    color: rgb(231, 76, 60);
  }

  .result-tie {
    color: rgb(255, 191, 0);
  }

  .result-upcoming {
    color: var(--blue);
  }

  .close-event-history {
    position: absolute;
    top: 10px;
    right: 15px;
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    z-index: 1001;
  }

  .event-history-title {
    text-align: center;
    margin-bottom: 20px;
    color: var(--gold);
    font-family: Starjedi, sans-serif;
    font-size: 1.5rem;
  }

  /* Adjust main content when event history is open */
  body.event-history-open .container {
    margin-left: 370px;
    transition: margin-left 0.3s ease;
  }

  @media (max-width: 768px) {
    .event-history-container {
      width: 100%;
    }
    
    body.event-history-open .container {
      margin-left: 0;
    }
    
    .alliance-teams {
      flex-direction: column;
      gap: 8px;
    }
  }
</style>
<script src="/js/auth.js"></script>
</head>
<body>
<!-- Mobile navigation -->
<div class="mobile-nav">
  <button class="hamburger" onclick="toggleMenu()">☰</button>
  <div class="mobile-menu" id="mobileMenu">
  <button class="mobile-menu-close" onclick="toggleMenu()">×</button>
  <a href="/" onclick="toggleMenu()">Home</a>
  <a href="/pages/pit_procedures.html" onclick="toggleMenu()">Pit Procedures</a>
  <a href="/pages/ondeck.html" onclick="toggleMenu()">Ondeck</a>
  <a href="/pages/match_scouting.html" onclick="toggleMenu()">Match Scouting</a>
  <a href="/pages/pit_scouting.html" onclick="toggleMenu()">Pit Scouting</a>
  <a href="/pages/team_summary.html" class="admin-only" onclick="toggleMenu()">Team Summary</a>
  <a href="/pages/match_simulator.html" onclick="toggleMenu()">Match Simulator</a>
  <a href="/pages/rankings.html" class="admin-only" onclick="toggleMenu()">Rankings</a>
  <a href="/pages/raw_match.html" onclick="toggleMenu()">Raw Match Data</a>
  <a href="/pages/raw_match_edit.html" class="admin-only" onclick="toggleMenu()">Raw Match Data Edit</a>
  <a href="/pages/raw_pit.html" onclick="toggleMenu()">Raw Pit Data</a>
  <a href="/pages/raw_pit_edit.html" class="admin-only" onclick="toggleMenu()">Raw Pit Data Edit</a>
  <a href="/pages/csv_upload.html" class="admin-only" onclick="toggleMenu()">CSV Upload</a>
  <a href="/pages/config_creator.html" onclick="toggleMenu()">Config Creator</a>
  <a href="/pages/admin.html" class="admin-only" onclick="toggleMenu()">User Management</a>
  <a href="/pages/logout.html" onclick="toggleMenu()">Logout</a>
  </div>
</div>
<script>
// Mobile menu functionality
function toggleMenu() {
  const menu = document.getElementById('mobileMenu');
  const isOpening = !menu.classList.contains('open');
  menu.classList.toggle('open');
  document.body.classList.toggle('menu-open', isOpening);
  if (isOpening) {
    setTimeout(() => {
      menu.scrollTop = 0;
    }, 50);
  }
}

// Close menu when clicking outside
document.addEventListener('click', function(event) {
  const menu = document.getElementById('mobileMenu');
  const hamburger = document.querySelector('.hamburger');
  if (menu.classList.contains('open') && 
      !menu.contains(event.target) && 
      event.target !== hamburger) {
    toggleMenu();
  }
});

// Close menu on escape key
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    const menu = document.getElementById('mobileMenu');
    if (menu.classList.contains('open')) {
      toggleMenu();
    }
  }
});

// Prevent background scrolling when menu is open
document.addEventListener('touchmove', function(event) {
  const menu = document.getElementById('mobileMenu');
  if (menu.classList.contains('open')) {
    if (!menu.contains(event.target)) {
      event.preventDefault();
    }
  }
}, { passive: false });
</script>
<!-- Original navbar (hidden on mobile) -->
<nav class="navbar">
  <a href="/">Home</a>
  <a href="/pages/pit_procedures.html">Pit Procedures</a>
  <a href="/pages/ondeck.html">Ondeck</a>
  <a href="/pages/match_scouting.html">Match Scouting</a>
  <a href="/pages/pit_scouting.html">Pit Scouting</a>
  <a href="/pages/team_summary.html" class="admin-only">Team Summary</a>
  <a href="/pages/match_simulator.html">Match Simulator</a>
  <a href="/pages/rankings.html" class="admin-only">Rankings</a>
  <a href="/pages/raw_match.html">Raw Match Data</a>
  <a href="/pages/raw_match_edit.html" class="admin-only">Raw Match Data Edit</a>
  <a href="/pages/raw_pit.html">Raw Pit Data</a>
  <a href="/pages/raw_pit_edit.html" class="admin-only">Raw Pit Data Edit</a>
  <a href="/pages/csv_upload.html" class="admin-only">CSV Upload</a>
  <a href="/pages/config_creator.html">Config Creator</a>
  <a href="/pages/admin.html" class="admin-only">User Management</a>
  <a href="/pages/logout.html">Logout</a>
</nav>
<div class="container admin-only">
<div class="container">
  <h1>Team Summary</h1>
  <div class="form-row">
    <label>Team Number</label>
    <div class="form-controls">
      <input id="team" type="number" placeholder="e.g., 4123"/>
      <button id="go" class="btn">Load</button>
    </div>
<div class="form-row">
  <label>Match Type Filter</label>
  <div class="form-controls">
    <select id="matchTypeFilter">
      <option value="all">All Matches</option>
      <option value="Practice">Practice</option>
      <option value="Qualification">Qualification</option>
      <option value="Semifinal">Semifinal</option>
      <option value="Final">Final</option>
    </select>
  </div>
  <div class="form-row">
  <label>Event Code Filter</label>
  <div class="form-controls">
    <select id="eventCodeFilter">
      <option value="all">All Events</option>
    </select>
  </div>
  <div class="trendline-options" id="trendlineOptions">
    <label>
      <input type="checkbox" id="showTrendlines" class="trendline-checkbox">
      Show Trendlines
    </label>
    <div class="trendline-type">
      <label>Type:</label>
      <select id="trendlineType">
        <option value="linear">Linear</option>
        <option value="polynomial">Polynomial</option>
        <option value="exponential">Exponential</option>
      </select>
    </div>
  </div>
</div>
</div>
  </div>
  <div class="event-history-toggle">
    <button id="toggleEventHistory" class="btn">Show Event History</button>
  </div>

  <div class="event-history-container" id="eventHistoryContainer">
    <button class="close-event-history" onclick="toggleEventHistory()">×</button>
    <h3 class="event-history-title">Event History for Team <span id="eventHistoryTeamNumber"></span> (<span id="eventHistoryYear"></span>)</h3>
    <div id="eventHistoryContent"></div>
  </div>
  <div id="teamInfo" class="card" style="display: none;">
    <h3>Team Information</h3>
    <div id="teamInfoContent"></div>
  </div>
<div id="teamStats" class="card" style="display: none;">
  <h3>Team Stats</h3>
  <div id="teamStatsContent"></div>
  <div id="matchTypeStats" style="margin-top: 15px; display: none;">
    <h4>Stats by Match Type</h4>
    <div id="matchTypeStatsContent"></div>
  </div>
</div>

  <div id="summary" class="card"></div>
  
  <div id="robotImageContainer" class="card" style="display: none;">
    <h3>Robot Image</h3>
    <div id="robotImage" class="robot-image-centered"></div>
  </div>
  <div id="chartsContainer"></div>
  <div id="tablesContainer"></div>
</div>
</div>
<footer>FRC 4123 Scouting • Conrad Oldoerp</footer>
<script>
// Function to get URL parameters
function getUrlParameter(name) {
    name = name.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    var results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}

// Load team from URL parameter if present
document.addEventListener('DOMContentLoaded', function() {
    const teamFromUrl = getUrlParameter('team');
    if (teamFromUrl) {
        document.getElementById('team').value = teamFromUrl;
        // Wait for auth to complete before loading team
        setTimeout(() => {
            if (document.getElementById('team').value) {
                loadTeam();
            }
        }, 500);
    }
});
</script>
<script>
let currentEventCodeFilter = 'all';
let uniqueEventCodes = [];
let eventHistoryData = [];
let currentTeamNumber = 0;
let configYear = 2025;
function getConfigYear() {
    if (config && config.team_summary && config.team_summary.team_info && config.team_summary.team_info.year) {
        return config.team_summary.team_info.year;
    }
    return 2025;
}
const TBA_KEY = "I6XNIQ0p8VtiUdy0u5oIVjmj7d4mGqteLwQczb91wyBCmd7439BPLxvqf6poH1wA";

// Add this function to fetch event history
async function fetchTeamEventHistory(teamNumber, year) {
  try {
    const response = await fetch(`https://www.thebluealliance.com/api/v3/team/frc${teamNumber}/events`, {
      headers: {
        'X-TBA-Auth-Key': TBA_KEY
      }
    });
    if (!response.ok) {
      throw new Error('Failed to fetch events');
    }
    const events = await response.json();
    const filteredEvents = events.filter(event => event.year === year);
    const eventPromises = filteredEvents.map(async event => {
      const matchesResponse = await fetch(`https://www.thebluealliance.com/api/v3/team/frc${teamNumber}/event/${event.key}/matches`, {
        headers: {
          'X-TBA-Auth-Key': TBA_KEY
        }
      });
      if (!matchesResponse.ok) {
        return { event, matches: [] };
      }
      const matches = await matchesResponse.json();
      return { event, matches };
    });
    const eventDetails = await Promise.all(eventPromises);
    return eventDetails;
  } catch (error) {
    console.error('Error fetching event history:', error);
    return [];
  }
}
function displayEventHistory(events) {
  const container = document.getElementById('eventHistoryContent');
  container.innerHTML = '';
  if (events.length === 0) {
    container.innerHTML = '<p>No event history found for ' + configYear + '</p>';
    return;
  }
  events.sort((a, b) => new Date(b.event.start_date) - new Date(a.event.start_date));
  events.forEach(eventData => {
    const event = eventData.event;
    const matches = eventData.matches;
    let wins = 0, losses = 0, ties = 0;
    const teamKey = `frc${currentTeamNumber}`;
    matches.sort((a, b) => {
      const compLevelPriority = {
        'f': 1,    // Final
        'sf': 2,   // Semifinal
        'qf': 3,   // Quarterfinal
        'ef': 4,   // Eightfinal
        'qm': 5,   // Qualification
        'pr': 6    // Practice
      };
      const aPriority = compLevelPriority[a.comp_level] || 999;
      const bPriority = compLevelPriority[b.comp_level] || 999;
      if (aPriority !== bPriority) {
        return aPriority - bPriority;
      }
      if (a.comp_level === 'f') {
        const aSetNum = parseInt(a.key.split('_').pop().replace('f', '').replace('m', ''));
        const bSetNum = parseInt(b.key.split('_').pop().replace('f', '').replace('m', ''));
        return bSetNum - aSetNum;
      } else if (a.comp_level === 'sf') {
        const aMatchNum = parseInt(a.key.split('_').pop().replace('sf', '').replace('m', ''));
        const bMatchNum = parseInt(b.key.split('_').pop().replace('sf', '').replace('m', ''));
        return bMatchNum - aMatchNum;
      } else {
        return b.match_number - a.match_number;
      }
    });
    matches.forEach(match => {
      if (match.alliances.red.score === null || match.alliances.blue.score === null) return;
      const isRed = match.alliances.red.team_keys.includes(teamKey);
      const redScore = match.alliances.red.score;
      const blueScore = match.alliances.blue.score;
      if (isRed) {
        if (redScore > blueScore) wins++;
        else if (redScore < blueScore) losses++;
        else ties++;
      } else {
        if (blueScore > redScore) wins++;
        else if (blueScore < redScore) losses++;
        else ties++;
      }
    });
    const eventCard = document.createElement('div');
    eventCard.className = 'event-card';
    eventCard.innerHTML = `
      <div class="event-header">
        <span class="event-name">${event.name}</span>
        <span class="event-record">${wins}-${losses}-${ties}</span>
      </div>
      <div class="match-breakdown">
        ${matches.length > 0 ? matches.map(match => {
          const teamKey = `frc${currentTeamNumber}`;
          const isRed = match.alliances.red.team_keys.includes(teamKey);
          const redScore = match.alliances.red.score;
          const blueScore = match.alliances.blue.score;
          const matchTime = new Date(match.time * 1000);
          let matchDisplayName = '';
          if (match.comp_level === 'qm') {
            matchDisplayName = `Qualification Match ${match.match_number}`;
          } else if (match.comp_level === 'pr') {
            matchDisplayName = `Practice Match ${match.match_number}`;
          } else if (match.comp_level === 'f') {
            // Finals: f1m1 → set 1, match 1
            const keyPart = match.key.split('_').pop(); // e.g. "f1m3"
            const setNumber = parseInt(keyPart.match(/f(\d+)/)[1]);
            const matchNumber = parseInt(keyPart.match(/m(\d+)/)[1]);
            matchDisplayName = `Finals ${matchNumber}`;
          } else if (match.comp_level === 'sf') {
            // Semifinals: sf2m1 → set 2, match 1
            const keyPart = match.key.split('_').pop(); // e.g. "sf2m1"
            const setNumber = parseInt(keyPart.match(/m(\d+)/)[1]);
            const matchNumber = parseInt(keyPart.match(/sf(\d+)/)[1]);
            matchDisplayName = `Semifinal ${matchNumber}`;
          }else {
            matchDisplayName = `${match.comp_level.toUpperCase()} Match ${match.match_number}`;
          }
          let statusClass = "upcoming";
          let statusText = "Scheduled";
          let resultClass = "result-upcoming";
          
          if (redScore !== null && blueScore !== null) {
            if (isRed) {
              if (redScore > blueScore) {
                statusClass = "win";
                statusText = "Win";
                resultClass = "result-win";
              } else if (redScore < blueScore) {
                statusClass = "loss";
                statusText = "Loss";
                resultClass = "result-loss";
              } else {
                statusClass = "tie";
                statusText = "Tie";
                resultClass = "result-tie";
              }
            } else {
              if (blueScore > redScore) {
                statusClass = "win";
                statusText = "Win";
                resultClass = "result-win";
              } else if (blueScore < redScore) {
                statusClass = "loss";
                statusText = "Loss";
                resultClass = "result-loss";
              } else {
                statusClass = "tie";
                statusText = "Tie";
                resultClass = "result-tie";
              }
            }
          }
          const formatAllianceTeams = (teamKeys, isTeamAlliance) => {
            return teamKeys.map(key => {
              const teamNum = key.substring(3);
              return isTeamAlliance && key === teamKey ? 
                `<span class="team-highlight">${teamNum}</span>` : teamNum;
            }).join(", ");
          };
          return `
            <div class="match-item ${statusClass}">
              <h4>${matchDisplayName}</h4>
              <div class="match-time">${matchTime.toLocaleString()}</div>
              <div class="alliance-teams">
                <div class="alliance red">
                  Red: ${formatAllianceTeams(match.alliances.red.team_keys, isRed)}
                </div>
                <div class="alliance blue">
                  Blue: ${formatAllianceTeams(match.alliances.blue.team_keys, !isRed)}
                </div>
              </div>
              <div class="score">
                ${redScore !== null ? 
                  `<span class="red-score">${redScore}</span> - 
                   <span class="blue-score">${blueScore}</span>` : 
                  'Not Played Yet'}
              </div>
              <div class="match-result ${resultClass}">
                ${statusText}
              </div>
            </div>
          `;
        }).join('') : '<p>No matches found for this event</p>'}
      </div>
    `;
    container.appendChild(eventCard);
  });
}

// Add this function to toggle event history
function toggleEventHistory() {
  const container = document.getElementById('eventHistoryContainer');
  const isOpening = !container.classList.contains('open');
  
  container.classList.toggle('open');
  document.body.classList.toggle('event-history-open', isOpening);
  
  const button = document.getElementById('toggleEventHistory');
  button.textContent = isOpening ? 'Hide Event History' : 'Show Event History';
  
  // Load event history if opening
  if (isOpening && eventHistoryData.length === 0 && currentTeamNumber) {
    button.textContent = 'Loading Events...';
    button.disabled = true;
    
    fetchTeamEventHistory(currentTeamNumber, configYear)
      .then(events => {
        eventHistoryData = events;
        document.getElementById('eventHistoryTeamNumber').textContent = currentTeamNumber;
        document.getElementById('eventHistoryYear').textContent = configYear;
        displayEventHistory(events);
        button.textContent = 'Hide Event History';
        button.disabled = false;
      })
      .catch(error => {
        console.error('Error loading event history:', error);
        document.getElementById('eventHistoryContent').innerHTML = '<p>Error loading event history</p>';
        button.textContent = 'Show Event History';
        button.disabled = false;
      });
  }
}

// Add event listener for the toggle button
document.getElementById('toggleEventHistory').addEventListener('click', toggleEventHistory);

function linearRegression(x, y) {
  const n = x.length;
  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
  
  for (let i = 0; i < n; i++) {
    sumX += x[i];
    sumY += y[i];
    sumXY += x[i] * y[i];
    sumXX += x[i] * x[i];
  }
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  return { slope, intercept };
}

function polynomialRegression(x, y, degree = 2) {
  // Simple implementation for quadratic regression
  if (degree !== 2) {
    console.warn("Only quadratic polynomial regression is implemented");
    return null;
  }
  
  const n = x.length;
  let sumX = 0, sumY = 0, sumXX = 0, sumXXX = 0, sumXXXX = 0, sumXY = 0, sumXXY = 0;
  
  for (let i = 0; i < n; i++) {
    const xi = x[i];
    const yi = y[i];
    const xx = xi * xi;
    const xxx = xx * xi;
    const xxxx = xxx * xi;
    
    sumX += xi;
    sumY += yi;
    sumXX += xx;
    sumXXX += xxx;
    sumXXXX += xxxx;
    sumXY += xi * yi;
    sumXXY += xx * yi;
  }
  
  // Solve the system of equations for quadratic regression
  // Using matrix inversion for 3x3 system
  const matrix = [
    [n, sumX, sumXX],
    [sumX, sumXX, sumXXX],
    [sumXX, sumXXX, sumXXXX]
  ];
  
  const vector = [sumY, sumXY, sumXXY];
  
  // Calculate determinant
  const det = matrix[0][0] * (matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1]) -
              matrix[0][1] * (matrix[1][0]*matrix[2][2] - matrix[1][2]*matrix[2][0]) +
              matrix[0][2] * (matrix[1][0]*matrix[2][1] - matrix[1][1]*matrix[2][0]);
  
  if (Math.abs(det) < 1e-10) {
    console.warn("Matrix is singular, cannot solve polynomial regression");
    return null;
  }
  
  // Calculate inverse matrix
  const invMatrix = [
    [
      matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1],
      matrix[0][2]*matrix[2][1] - matrix[0][1]*matrix[2][2],
      matrix[0][1]*matrix[1][2] - matrix[0][2]*matrix[1][1]
    ],
    [
      matrix[1][2]*matrix[2][0] - matrix[1][0]*matrix[2][2],
      matrix[0][0]*matrix[2][2] - matrix[0][2]*matrix[2][0],
      matrix[0][2]*matrix[1][0] - matrix[0][0]*matrix[1][2]
    ],
    [
      matrix[1][0]*matrix[2][1] - matrix[1][1]*matrix[2][0],
      matrix[0][1]*matrix[2][0] - matrix[0][0]*matrix[2][1],
      matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]
    ]
  ].map(row => row.map(val => val / det));
  
  // Multiply inverse matrix by vector
  const a = invMatrix[0][0]*vector[0] + invMatrix[0][1]*vector[1] + invMatrix[0][2]*vector[2];
  const b = invMatrix[1][0]*vector[0] + invMatrix[1][1]*vector[1] + invMatrix[1][2]*vector[2];
  const c = invMatrix[2][0]*vector[0] + invMatrix[2][1]*vector[1] + invMatrix[2][2]*vector[2];
  
  return { a, b, c };
}

function exponentialRegression(x, y) {
  // Transform y values to log space for linear regression
  const logY = y.map(val => Math.log(val));
  const linear = linearRegression(x, logY);
  
  if (!linear) return null;
  
  // Convert back to exponential form: y = a * e^(b*x)
  const a = Math.exp(linear.intercept);
  const b = linear.slope;
  
  return { a, b };
}  

/**
 * Waits for the authentication module to be fully initialized before proceeding.
 * This ensures auth checks don't run before the auth system is ready.
 */
function waitForAuth() {
    return new Promise((resolve) => {
        if (window.auth && window.auth.isInitialized) {
            resolve();
        } else {
            setTimeout(() => waitForAuth().then(resolve), 100);
        }
    });
}

/**
 * Checks if the user is authenticated and has admin privileges.
 * Redirects to login if not authenticated, shows access denied if not admin.
 */
async function checkAuth() {
    await waitForAuth();
    if (!auth.isLoggedIn()) {
        const currentPath = encodeURIComponent(window.location.pathname + window.location.search);
        window.location.href = `/login.html?redirect=${currentPath}`;
        return false;
    }
    if (!auth.isAdmin()) {
        document.body.innerHTML = `
            <div class="container">
                <h2>Access Denied</h2>
                <p>You need administrator privileges to access the Team Summary page.</p>
                <a href="/">Return to Home</a>
            </div>
        `;
        return false;
    }
    
    return true;
}

/**
 * Retrieves authentication headers for API requests using the stored token.
 */
function getAuthHeaders() {
    const token = localStorage.getItem('authToken');
    return token ? { 'Authorization': token } : {};
}

let charts = {};
let config = null;
let allProcessedData = [];
let currentMatchTypeFilter = 'all';

/**
 * Safely retrieves nested values from an object using dot notation path.
 * Returns 0 if any part of the path is undefined.
 */
function getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
        return current && current[key] !== undefined ? current[key] : 0;
    }, obj);
}

// JavaScript equivalents of SQL functions
const sqlFunctions = {
    ROUND: (value, precision = 0) => {
        const multiplier = Math.pow(10, precision);
        return Math.round(value * multiplier) / multiplier;
    },
    COALESCE: (...args) => {
        for (let arg of args) {
            if (arg !== null && arg !== undefined && !Number.isNaN(arg)) {
                return arg;
            }
        }
        return 0;
    }
};

/**
 * Replaces SQL function calls in expressions with JavaScript equivalents.
 * Handles ROUND and COALESCE functions specifically.
 */
function replaceSqlFunctions(expression) {
    expression = expression.replace(/ROUND\(([^,)]+),\s*([^)]+)\)/g, (match, value, precision) => {
        return `sqlFunctions.ROUND(${value}, ${precision})`;
    });
    expression = expression.replace(/ROUND\(([^)]+)\)/g, (match, value) => {
        return `sqlFunctions.ROUND(${value})`;
    });
    expression = expression.replace(/COALESCE\(([^)]+)\)/g, (match, args) => {
        return `sqlFunctions.COALESCE(${args})`;
    });
    return expression;
}

/**
 * Safely parses JSON strings or returns objects as-is.
 * Handles cases where input might already be parsed or invalid JSON.
 */
function parseMaybeJSON(v) {
    if (v == null) return {};
    if (typeof v === 'string') {
        try { return JSON.parse(v); } catch (e) { console.warn('parse error', e, v); return {}; }
    }
    if (typeof v === 'object') return v;
    return {};
}

/**
 * Calculates computed field values based on configuration formulas.
 * Handles complex expressions, SQL functions, and field dependencies.
 */
function calculateField(row, fieldName, computedFields, processedRow = null) {
    const formula = computedFields[fieldName];
    if (!formula) return 0;
    const preMatch = parseMaybeJSON(row.pre_match_json);
    const auto = parseMaybeJSON(row.auto_json);
    const teleop = parseMaybeJSON(row.teleop_json);
    const endgame = parseMaybeJSON(row.endgame_json);
    const misc = parseMaybeJSON(row.misc_json);
    const config = window.config || {};
    const autoValues = config.match_form?.auto_period || {};
    const teleopValues = config.match_form?.teleop_period || {};
    if (fieldName === 'left_starting_zone') {
        const auto = parseMaybeJSON(row.auto_json);
        const leftStartingZone = getNestedValue(auto, 'left_starting_zone');
        if (typeof leftStartingZone === 'boolean') {
            const configValue = getNestedValue(config, 'match_form.auto_period.left_starting_zone.Value');
            if (configValue !== undefined) {
                return leftStartingZone ? configValue : 0;
            }
        }
        return leftStartingZone ? 3 : 0;
    }
    if (formula.startsWith('json_extract(pre_match_json,')) {
        const fieldMatch = formula.match(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/);
        if (fieldMatch) {
            const value = getNestedValue(preMatch, fieldMatch[1]);
            return value;
        }
    }
    if (formula.startsWith('json_extract(') && !formula.includes('+') && !formula.includes('*') && !formula.includes('CASE')) {
        if (formula.includes('pre_match_json')) {
            const fieldMatch = formula.match(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(preMatch, fieldMatch[1]);
        }
        if (formula.includes('auto_json')) {
            const fieldMatch = formula.match(/json_extract\(auto_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(auto, fieldMatch[1]) || 0;
        }
        if (formula.includes('teleop_json')) {
            const fieldMatch = formula.match(/json_extract\(teleop_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(teleop, fieldMatch[1]) || 0;
        }
        if (formula.includes('endgame_json')) {
            const fieldMatch = formula.match(/json_extract\(endgame_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(endgame, fieldMatch[1]) || 0;
        }
        if (formula.includes('misc_json')) {
            const fieldMatch = formula.match(/json_extract\(misc_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(misc, fieldMatch[1]) || 0;
        }
    }
    if (formula.includes('CASE json_extract(endgame_json') && formula.includes('final_status')) {
        const finalStatus = getNestedValue(endgame, 'final_status');
        const statusValues = {
            'Park': 2,
            'Failed Climb': 2,
            'Shallow Climb': 6,
            'Deep Climb': 12
        };
        const value = statusValues[finalStatus] || 0;
        return value;
    }
    let result = formula;
    result = result.replace(/config\('([^']+)'\)/g, (match, configPath) => {
        const value = getNestedValue(config, configPath);
        return value !== undefined ? value : 0;
    });
    result = result.replace(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(preMatch, field);
        return typeof value === 'string' ? `"${value}"` : (value || 0);
    });
    result = result.replace(/json_extract\(auto_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(auto, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(teleop_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(teleop, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(endgame_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(endgame, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(misc_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(misc, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(auto_json,\s*'\$\.([^.]+)\.Value'\)/g, (match, field) => {
        let value = 0;
        if (config.match_form?.auto_period?.[field]?.Value !== undefined) {
            value = config.match_form.auto_period[field].Value;
        }
        return value;
    });
    result = result.replace(/json_extract\(teleop_json,\s*'\$\.([^.]+)\.Value'\)/g, (match, field) => {
        let value = 0;
        if (config.match_form?.teleop_period?.[field]?.Value !== undefined) {
            value = config.match_form.teleop_period[field].Value;
        }
        return value;
    });
    if (processedRow) {
        for (const key in processedRow) {
            if (processedRow.hasOwnProperty(key) && result.includes(key)) {
                result = result.replace(new RegExp(`\\b${key}\\b`, 'g'), processedRow[key]);
            }
        }
    }
    const fieldPattern = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
    const fieldsToReplace = [];
    let match;
    while ((match = fieldPattern.exec(result)) !== null) {
        const fieldRef = match[1];
        if (computedFields[fieldRef] && fieldRef !== fieldName && 
            !['CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'ROUND', 'COALESCE', 'sqlFunctions', 'config'].includes(fieldRef)) {
            fieldsToReplace.push(fieldRef);
        }
    }
    for (const fieldRef of fieldsToReplace) {
        const fieldValue = calculateField(row, fieldRef, computedFields, processedRow);
        result = result.replace(new RegExp(`\\b${fieldRef}\\b`, 'g'), fieldValue);
    }
    result = replaceSqlFunctions(result);
    if (result.includes('CASE WHEN') && result.includes('THEN') && result.includes('ELSE')) {
        try {
            const casePattern = /CASE WHEN\s+(.+?)\s+THEN\s+(.+?)\s+ELSE\s+(.+?)\s+END/;
            const caseMatch = result.match(casePattern);
            if (caseMatch) {
                const conditionExpr = caseMatch[1].trim();
                const thenExpr = caseMatch[2].trim();
                const elseExpr = caseMatch[3].trim();
                const condition = eval(conditionExpr);
                const finalValue = condition ? eval(thenExpr) : eval(elseExpr);
                
                return finalValue;
            }
        } catch (e) {
            console.warn('Failed to evaluate CASE statement:', result, e);
            return 0;
        }
    }
    try {
        const finalValue = eval(result);
        return finalValue || 0;
    } catch (e) {
        console.warn('Failed to evaluate formula:', result, e);
        return 0;
    }
}

/**
 * Extracts unique event codes from processed data
 */
function extractUniqueEventCodes(processedData) {
    const eventCodes = new Set();
    processedData.forEach(match => {
        const eventCode = match.event_code || (match.pre_match_json && match.pre_match_json.event_code) || 'Unknown';
        if (eventCode && eventCode !== 'Unknown') {
            eventCodes.add(eventCode);
        }
    });
    return Array.from(eventCodes).sort();
}

/**
 * Populates the event code filter dropdown
 */
function populateEventCodeFilter(eventCodes) {
    const filter = document.getElementById('eventCodeFilter');
    // Keep the "All Events" option
    const allOption = filter.querySelector('option[value="all"]');
    filter.innerHTML = '';
    filter.appendChild(allOption);
    
    eventCodes.forEach(code => {
        const option = document.createElement('option');
        option.value = code;
        option.textContent = code;
        filter.appendChild(option);
    });
}

/**
 * Filters data based on both match type and event code
 */
function filterData(processedData, matchTypeFilter, eventCodeFilter) {
    return processedData.filter(match => {
        // Match type filter
        const matchTypeMatch = matchTypeFilter === 'all' || match.match_type === matchTypeFilter;
        
        // Event code filter
        const eventCode = match.event_code || (match.pre_match_json && match.pre_match_json.event_code) || 'Unknown';
        const eventCodeMatch = eventCodeFilter === 'all' || eventCode === eventCodeFilter;
        
        return matchTypeMatch && eventCodeMatch;
    });
}

/**
 * Creates a Chart.js chart based on configuration and processed data.
 * Handles both single and multiple dataset configurations.
 */
function createChart(chartName, chartConfig, processedData) {
  const canvasId = `chart_${chartName.replace(/\s+/g, '_')}_${Date.now()}`;
  const canvas = document.createElement('canvas');
  canvas.id = canvasId;
  canvas.width = 400;
  canvas.height = 300;
  
  const card = document.createElement('div');
  card.className = 'card chart-with-trendline';
  card.innerHTML = `<h3>${chartName}</h3>`;
  card.appendChild(canvas);
  
  const equationDiv = document.createElement('div');
  equationDiv.className = 'trendline-equation';
  equationDiv.style.display = 'none';
  card.appendChild(equationDiv);
  
  const ctx = canvas.getContext('2d');
  const labels = processedData.map(row => row[chartConfig.x] || 'N/A');
  
  let datasets = [];
  if (Array.isArray(chartConfig.y)) {
    const colors = [
      'rgba(255, 99, 132, 0.7)',
      'rgba(54, 162, 235, 0.7)',
      'rgba(255, 205, 86, 0.7)',
      'rgba(75, 192, 192, 0.7)',
      'rgba(153, 102, 255, 0.7)',
      'rgba(255, 159, 64, 0.7)'
    ];
    
    chartConfig.y.forEach((yField, index) => {
      datasets.push({
        label: yField.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        data: processedData.map(row => row[yField] || 0),
        backgroundColor: colors[index % colors.length],
        borderColor: colors[index % colors.length].replace('0.7', '1'),
        borderWidth: 2,
        fill: false
      });
    });
  } else {
    datasets.push({
      label: chartConfig.y.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      data: processedData.map(row => row[chartConfig.y] || 0),
      backgroundColor: chartConfig.backgroundColor || 'rgba(153, 102, 255, 0.2)',
      borderColor: chartConfig.borderColor || 'rgba(153, 102, 255, 1)',
      borderWidth: 2,
      fill: true,
      tension: 0.1
    });
  }
  
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        intersect: false,
        mode: 'index'
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: chartConfig.y_label || 'Value'
          }
        },
        x: {
          title: {
            display: true,
            text: chartConfig.x_label || 'Match'
          }
        }
      },
      layout: {
        padding: 10
      }
    }
  });
  
  // Store reference to add trendline later
  chart.trendlineData = {
    chartConfig,
    processedData,
    equationDiv
  };
  
  charts[canvasId] = chart;
  return card;
}


function addTrendlineToChart(chart, trendlineType) {
  // Remove existing trendline datasets if any
  chart.data.datasets = chart.data.datasets.filter(ds => !ds.isTrendline);
  
  // For simplicity, we'll add trendlines only to the first dataset
  if (chart.data.datasets.length === 0) return;
  
  const mainDataset = chart.data.datasets[0];
  const dataPoints = mainDataset.data;
  const labels = chart.data.labels;
  
  // Convert labels to numeric values for regression
  const xValues = labels.map((label, index) => {
    // Try to parse as number, otherwise use index
    const num = Number(label);
    return isNaN(num) ? index + 1 : num;
  });
  
  const yValues = dataPoints.map(point => point);
  
  let trendlineData = [];
  let equation = '';
  
  switch(trendlineType) {
    case 'linear':
      const linear = linearRegression(xValues, yValues);
      if (linear) {
        trendlineData = xValues.map(x => linear.slope * x + linear.intercept);
        equation = `y = ${linear.slope.toFixed(2)}x + ${linear.intercept.toFixed(2)}`;
      }
      break;
      
    case 'polynomial':
      const poly = polynomialRegression(xValues, yValues, 2);
      if (poly) {
        trendlineData = xValues.map(x => poly.a + poly.b * x + poly.c * x * x);
        equation = `y = ${poly.a.toFixed(2)} + ${poly.b.toFixed(2)}x + ${poly.c.toFixed(2)}x²`;
      }
      break;
      
    case 'exponential':
      // Check if all y values are positive for exponential regression
      if (yValues.every(y => y > 0)) {
        const exp = exponentialRegression(xValues, yValues);
        if (exp) {
          trendlineData = xValues.map(x => exp.a * Math.exp(exp.b * x));
          equation = `y = ${exp.a.toFixed(2)}e^(${exp.b.toFixed(2)}x)`;
        }
      } else {
        console.warn("Cannot compute exponential regression with non-positive values");
      }
      break;
  }
  
  if (trendlineData.length > 0) {
    // Add trendline dataset
    chart.data.datasets.push({
      label: `${trendlineType} trendline`,
      data: trendlineData,
      borderColor: 'rgba(255, 0, 0, 0.8)',
      backgroundColor: 'rgba(255, 0, 0, 0.1)',
      borderWidth: 2,
      pointRadius: 0,
      fill: false,
      tension: 0,
      isTrendline: true
    });
    
    // Show equation
    chart.trendlineData.equationDiv.textContent = equation;
    chart.trendlineData.equationDiv.style.display = 'block';
    
    chart.update();
  }
}


function updateAllTrendlines() {
  const showTrendlines = document.getElementById('showTrendlines').checked;
  const trendlineType = document.getElementById('trendlineType').value;
  
  // Update trendline options UI
  const optionsDiv = document.getElementById('trendlineOptions');
  if (showTrendlines) {
    optionsDiv.classList.add('active');
  } else {
    optionsDiv.classList.remove('active');
  }
  
  // Update all charts
  Object.values(charts).forEach(chart => {
    // Remove existing trendlines
    chart.data.datasets = chart.data.datasets.filter(ds => !ds.isTrendline);
    chart.trendlineData.equationDiv.style.display = 'none';
    
    // Add new trendlines if enabled
    if (showTrendlines) {
      addTrendlineToChart(chart, trendlineType);
    } else {
      chart.update();
    }
  });
}


/**
 * Creates a data table based on configuration and processed data.
 * Displays specified columns in a tabular format.
 */
function createTable(tableName, tableConfig, processedData) {
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<h3>${tableName}</h3>`;
    const table = document.createElement('table');
    table.className = 'table';
    const thead = document.createElement('tr');
    tableConfig.columns.forEach(colName => {
        const th = document.createElement('th');
        th.textContent = colName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        thead.appendChild(th);
    });
    table.appendChild(thead);
    processedData.forEach(row => {
        const tr = document.createElement('tr');
        tableConfig.columns.forEach(colName => {
            const td = document.createElement('td');
            const value = row[colName];
            td.textContent = value !== undefined ? value : 'N/A';
            tr.appendChild(td);
        });
        table.appendChild(tr);
    });
    card.appendChild(table);
    return card;
}

/**
 * Loads team information from external API and displays it.
 * Fetches team name, EPA, and ranking data based on configuration.
 */
async function loadTeamInfo(team, config) {
    const teamInfoContainer = document.getElementById('teamInfo');
    const teamInfoContent = document.getElementById('teamInfoContent');
    const teamStatsContainer = document.getElementById('teamStats');
    const teamStatsContent = document.getElementById('teamStatsContent');
    teamInfoContainer.style.display = 'none';
    teamStatsContainer.style.display = 'none';
    teamInfoContent.innerHTML = '';
    teamStatsContent.innerHTML = '';
    //console.log('Full config:', config);
    try {
        let teamInfoConfig = null;
        if (config?.team_summary?.team_info) {
            teamInfoConfig = config.team_summary.team_info;
        } else if (config?.team_info) {
            teamInfoConfig = config.team_info;
        } else if (config?.team_summary) {
            teamInfoConfig = config.team_summary;
        }
        console.log('Team info config found:', teamInfoConfig);
        if (!teamInfoConfig) {
            console.warn('No team info configuration found in config');
            return;
        }
        const shouldFetch = Object.values(teamInfoConfig).some(val => val === true && 
            typeof val === 'boolean' && 
            !['year'].includes(Object.keys(teamInfoConfig)[Object.values(teamInfoConfig).indexOf(val)]));
        
        console.log('Should fetch team info:', shouldFetch);
        if (!shouldFetch) {
            return;
        }
        const year = teamInfoConfig.year || 2025;
        console.log('Fetching team info for year:', year);
        const response = await fetch(`/api/team/${team}/info?year=${year}`, {
            headers: getAuthHeaders()
        });
        const data = await response.json();
        console.log('Team info API response:', data);
        if (data.error) {
            console.warn('Team info API error:', data.error);
            return;
        }
        let infoHtml = '<div class="team-info-grid">';
        let hasInfo = false;
        if (teamInfoConfig.get_team_name && data.name) {
            infoHtml += `<div class="info-item"><strong>Team Name:</strong> ${data.name}</div>`;
            hasInfo = true;
        }
        infoHtml += '</div>';
        if (hasInfo) {
            teamInfoContent.innerHTML = infoHtml;
            teamInfoContainer.style.display = 'block';
        }
        let statsHtml = '<div class="team-stats-grid">';
        let hasStats = false;
        if (teamInfoConfig.get_team_epa && data.epa !== null && data.epa !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.epa.toFixed(1)}</div>
                    <div class="stat-label">EPA</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_state && data.state_rank !== null && data.state_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.state_rank}/${data.state_total || '?'}</div>
                    <div class="stat-label">State Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_country && data.country_rank !== null && data.country_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.country_rank}/${data.country_total || '?'}</div>
                    <div class="stat-label">Country Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_world && data.world_rank !== null && data.world_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.world_rank}/${data.world_total || '?'}</div>
                    <div class="stat-label">World Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_district && data.district_rank !== null && data.district_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.district_rank}/${data.district_total || '?'}</div>
                    <div class="stat-label">District Rank</div>
                </div>
            `;
            hasStats = true;
        }
        statsHtml += '</div>';
        if (hasStats) {
            teamStatsContent.innerHTML = statsHtml;
            teamStatsContainer.style.display = 'block';
        }
    } catch (error) {
        console.error('Error loading team info:', error);
    }
}

/**
 * Calculates and displays statistics grouped by match type.
 * Shows average scores for each match type category.
 */
function displayMatchTypeStats(processedData) {
    const matchTypeStatsContainer = document.getElementById('matchTypeStats');
    const matchTypeStatsContent = document.getElementById('matchTypeStatsContent');
    if (!processedData.length) {
        matchTypeStatsContainer.style.display = 'none';
        return;
    }
    const matchTypes = {};
    processedData.forEach(match => {
        const type = match.match_type || 'Unknown';
        if (!matchTypes[type]) {
            matchTypes[type] = {
                count: 0,
                totalAuto: 0,
                totalTeleop: 0,
                totalEndgame: 0,
                totalPoints: 0
            };
        }
        matchTypes[type].count++;
        matchTypes[type].totalAuto += match.auto_points || 0;
        matchTypes[type].totalTeleop += match.teleop_points || 0;
        matchTypes[type].totalEndgame += match.endgame_points || 0;
        matchTypes[type].totalPoints += match.total_points || 0;
    });
    let statsHtml = '<div class="match-type-stats-grid">';
    for (const [type, stats] of Object.entries(matchTypes)) {
        const avgAuto = stats.count > 0 ? stats.totalAuto / stats.count : 0;
        const avgTeleop = stats.count > 0 ? stats.totalTeleop / stats.count : 0;
        const avgEndgame = stats.count > 0 ? stats.totalEndgame / stats.count : 0;
        const avgTotal = stats.count > 0 ? stats.totalPoints / stats.count : 0;
        statsHtml += `
            <div class="match-type-stat-item">
                <div class="match-type-stat-label">${type}</div>
                <div class="match-type-stat-count">${stats.count} matches</div>
                <div class="match-type-stat-value">${avgTotal.toFixed(1)}</div>
                <div>Total Points</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">
                    Auto: ${avgAuto.toFixed(1)} | Teleop: ${avgTeleop.toFixed(1)} | Endgame: ${avgEndgame.toFixed(1)}
                </div>
            </div>
        `;
    }
    statsHtml += '</div>';
    matchTypeStatsContent.innerHTML = statsHtml;
    matchTypeStatsContainer.style.display = 'block';
}

/**
 * Main function to load and display team data, charts, and statistics.
 * Orchestrates the entire data loading and visualization process.
 */
async function loadTeam(){
    const isAuthenticated = await checkAuth();
    if (!isAuthenticated) return;
    const team = document.getElementById('team').value;
    if (!team) return;
    currentTeamNumber = parseInt(team);
    currentMatchTypeFilter = document.getElementById('matchTypeFilter').value;
    currentEventCodeFilter = document.getElementById('eventCodeFilter').value;
    try {
        const configResp = await fetch('/api/config').then(r => r.json());
        config = configResp;
        window.config = configResp;
        configYear = getConfigYear();
        await loadTeamInfo(team, configResp);
        const [avgResp, rowsResp] = await Promise.all([
            fetch(`/api/team/${team}/averages`, {
                headers: getAuthHeaders()
            }).then(r => r.json()),
            fetch(`/api/team/${team}/matches`, {
                headers: getAuthHeaders()
            }).then(r => r.json())
        ]);
        if (avgResp.error) {
            document.getElementById('summary').innerHTML = `Error: ${avgResp.error}`;
            return;
        }
        const response = await fetch(
            `/api/team/${team}/averages?match_type=${currentMatchTypeFilter}&event_code=${currentEventCodeFilter}`, 
            { headers: getAuthHeaders() }
        );

        const data = await response.json();

        if (data.error) {
            console.warn("Error from API:", data.error);
            return;
        }
        const summaryDiv = document.getElementById('summary');
        summaryDiv.innerHTML = `
        <h3>Team Summary</h3>
        <div class="score-row">
            <span>Matches: <strong>${data.matches}</strong></span>
            <span>Avg Auto: <strong>${data.avg_auto.toFixed(2)}</strong></span>
            <span>Avg Teleop: <strong>${data.avg_teleop.toFixed(2)}</strong></span>
            <span>Avg Endgame: <strong>${data.avg_endgame.toFixed(2)}</strong></span>
            <span>Avg Total: <strong>${data.avg_total.toFixed(2)}</strong></span>
        </div>
        `;
        let teamPitData = null;
        try {
            teamPitData = await fetch(`/api/team/${team}/pit`, {
                headers: getAuthHeaders()
            }).then(r => r.json());
        } catch (e) {
            console.log('Could not load pit data:', e);
        }
        const imageContainer = document.getElementById('robotImageContainer');
        const robotImageDiv = document.getElementById('robotImage');
        if (teamPitData && teamPitData.pit_json && teamPitData.pit_json.image_upload) {
            imageContainer.style.display = 'block';
            robotImageDiv.innerHTML = `<img src="${teamPitData.pit_json.image_upload}" style="max-width: 100%; max-height: 400px;" alt="Robot Image">`;
        } else {
            imageContainer.style.display = 'none';
        }
        Object.values(charts).forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        charts = {};
        document.getElementById('chartsContainer').innerHTML = '';
        document.getElementById('tablesContainer').innerHTML = '';
        const teamSummaryConfig = config.team_summary;
        const computedFields = teamSummaryConfig.computed_fields || {};
        allProcessedData = rowsResp.map(row => {
            const pre = parseMaybeJSON(row.pre_match_json);
            const processed = {
                match_number: pre.match_number,
                match_type: pre.match_type || 'Unknown',
                event_code: pre.event_code || 'Unknown',
                team_color: pre.team_color,
                auto_points: row.auto_points,
                teleop_points: row.teleop_points,
                endgame_points: row.endgame_points,
                total_points: row.total_points,
                created_at: row.created_at
            };
            for (const fieldName of Object.keys(computedFields)) {
                try {
                    if (!computedFields[fieldName].includes('auto_L') && 
                        !computedFields[fieldName].includes('teleop_L') &&
                        !computedFields[fieldName].includes('CASE WHEN')) {
                        processed[fieldName] = calculateField(row, fieldName, computedFields, processed);
                    }
                } catch (e) {
                    console.warn('compute failed for', fieldName, e);
                    processed[fieldName] = 0;
                }
            }
            for (const fieldName of Object.keys(computedFields)) {
                try {
                    if (computedFields[fieldName].includes('auto_L') || 
                        computedFields[fieldName].includes('teleop_L') ||
                        computedFields[fieldName].includes('CASE WHEN')) {
                        processed[fieldName] = calculateField(row, fieldName, computedFields, processed);
                    }
                } catch (e) {
                    console.warn('compute failed for', fieldName, e);
                    processed[fieldName] = 0;
                }
            }
            return processed;
        });
        uniqueEventCodes = extractUniqueEventCodes(allProcessedData);
        populateEventCodeFilter(uniqueEventCodes);
        const matchTypeOrder = {
            'Practice': 1,
            'Qualification': 2,
            'Semifinal': 3,
            'Final': 4,
            'Unknown': 5
        };
        allProcessedData.sort((a, b) => {
            const typeA = a.match_type || 'Unknown';
            const typeB = b.match_type || 'Unknown';
            if (matchTypeOrder[typeA] !== matchTypeOrder[typeB]) {
                return matchTypeOrder[typeA] - matchTypeOrder[typeB];
            }
            if (a.match_number && b.match_number) {
                return a.match_number - b.match_number;
            }
            return new Date(a.created_at) - new Date(b.created_at);
        });
        const filteredData = filterData(
            allProcessedData, 
            currentMatchTypeFilter, 
            currentEventCodeFilter
        );


        
        displayMatchTypeStats(allProcessedData);
        if (teamSummaryConfig.body.charts) {
            const chartEntries = Object.entries(teamSummaryConfig.body.charts);
            const container = document.getElementById('chartsContainer');
            const chartPairs = [
                ['Auto Coral Performance', 'Teleop Coral Performance'],
                ['Auto Coral Accuracy', 'Teleop Coral Accuracy']
            ];
            const usedCharts = new Set();
            chartPairs.forEach(pair => {
                const [chart1Name, chart2Name] = pair;
                const chart1Entry = chartEntries.find(([name]) => name === chart1Name);
                const chart2Entry = chartEntries.find(([name]) => name === chart2Name);
                if (chart1Entry && chart2Entry) {
                    const row = document.createElement('div');
                    row.className = 'charts-row';
                    const container1 = document.createElement('div');
                    container1.className = 'chart-container';
                    const card1 = createChart(chart1Entry[0], chart1Entry[1], filteredData);
                    container1.appendChild(card1);
                    const container2 = document.createElement('div');
                    container2.className = 'chart-container';
                    const card2 = createChart(chart2Entry[0], chart2Entry[1], filteredData);
                    container2.appendChild(card2);
                    row.appendChild(container1);
                    row.appendChild(container2);
                    container.appendChild(row);
                    usedCharts.add(chart1Name);
                    usedCharts.add(chart2Name);
                }
            });
            chartEntries.forEach(([chartName, chartConfig]) => {
                if (!usedCharts.has(chartName)) {
                    const row = document.createElement('div');
                    row.className = 'charts-row';
                    const container1 = document.createElement('div');
                    container1.className = 'chart-container';
                    const card = createChart(chartName, chartConfig, filteredData);
                    container1.appendChild(card);
                    row.appendChild(container1);
                    container.appendChild(row);
                }
            });
        }
        if (teamSummaryConfig.body.tables && teamSummaryConfig.body.tables.table) {
            const tablesContainer = document.getElementById('tablesContainer');
            Object.entries(teamSummaryConfig.body.tables.table).forEach(([tableName, tableConfig]) => {
                const displayName = tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const tableCard = createTable(displayName, tableConfig, filteredData);
                tablesContainer.appendChild(tableCard);
            });
        }
    } catch (error) {
        console.error('Error loading team data:', error);
        document.getElementById('summary').innerHTML = 'Error loading team data. Please try again.';
    }
      setTimeout(() => {
    updateAllTrendlines();
  }, 100);
}

// Event listeners
document.getElementById('go').addEventListener('click', loadTeam);

// Load on Enter key in team input
document.getElementById('team').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') loadTeam();
});

// Add event listener for the match type filter
document.getElementById('matchTypeFilter').addEventListener('change', function() {
    if (document.getElementById('team').value) {
        loadTeam();
    }
});

// Add event listener for the event code filter
document.getElementById('eventCodeFilter').addEventListener('change', function() {
    if (document.getElementById('team').value) {
        loadTeam();
    }
});

// Check authentication when page loads
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
});

document.getElementById('showTrendlines').addEventListener('change', updateAllTrendlines);
document.getElementById('trendlineType').addEventListener('change', updateAllTrendlines);   
</script>

</body></html>