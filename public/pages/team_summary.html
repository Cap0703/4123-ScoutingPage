<!doctype html>
<html><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Team Summary</title>
<link rel="stylesheet" href="/css/style.css"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
.charts-row {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
}
.chart-container {
  flex: 1;
  min-width: 0;
}
.chart-container .card {
  margin: 0;
  height: 400px;
  display: flex;
  flex-direction: column;
}
.chart-container canvas {
  flex: 1;
  min-height: 0;
}
@media (max-width: 768px) {
  .charts-row {
    flex-direction: column;
  }
}
.team-info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
}

.info-item {
  padding: 8px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

.team-stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
  margin-bottom: 20px;
}

.stat-item {
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  text-align: center;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #d4af37;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

.robot-image-centered {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.robot-image-centered h3 {
  width: 100%;
  text-align: center;
  margin-bottom: 15px;
}

.robot-image-centered img {
  display: block;
  margin: 0 auto;
  max-width: 100%;
  max-height: 400px;
}
.match-type-stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.match-type-stat-item {
  padding: 12px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  text-align: center;
}

.match-type-stat-value {
  font-size: 1.3rem;
  font-weight: bold;
  color: #4ecdc4;
}

.match-type-stat-label {
  font-size: 0.85rem;
  opacity: 0.8;
  margin-bottom: 5px;
}

.match-type-stat-count {
  font-size: 0.8rem;
  opacity: 0.7;
}
</style>
<script src="/js/auth.js"></script>
</head>
<body>
<div class="mobile-nav">
  <button class="hamburger" onclick="toggleMenu()">☰</button>
  <div class="mobile-menu" id="mobileMenu">
    <button class="mobile-menu-close" onclick="toggleMenu()">×</button>
  <a href="/">Home</a>
  <a href="/pages/match_scouting.html">Match Scouting</a>
  <a href="/pages/pit_scouting.html">Pit Scouting</a>
  <a href="/pages/team_summary.html" class="admin-only">Team Summary</a>
  <a href="/pages/match_simulator.html">Match Simulator</a>
  <a href="/pages/rankings.html" class="admin-only">Rankings</a>
  <a href="/pages/raw_match.html">Raw Match Data</a>
  <a href="/pages/raw_match_edit.html" class="admin-only">Raw Match Data Edit</a>
  <a href="/pages/raw_pit.html">Raw Pit Data</a>
  <a href="/pages/raw_pit_edit.html" class="admin-only">Raw Pit Data Edit</a>
  <a href="/pages/csv_upload.html" class="admin-only">CSV Upload</a>
  <a href="/pages/config_creator.html">Config Creator</a>
  <a href="/pages/admin.html" class="admin-only">User Management</a>
  <a href="/pages/logout.html">Logout</a>
  </div>
</div>
<script>
// Mobile menu functionality
function toggleMenu() {
  const menu = document.getElementById('mobileMenu');
  const isOpening = !menu.classList.contains('open');
  menu.classList.toggle('open');
  document.body.classList.toggle('menu-open', isOpening);
  if (isOpening) {
    setTimeout(() => {
      menu.scrollTop = 0;
    }, 50);
  }
}

// Close menu when clicking outside
document.addEventListener('click', function(event) {
  const menu = document.getElementById('mobileMenu');
  const hamburger = document.querySelector('.hamburger');
  if (menu.classList.contains('open') && 
      !menu.contains(event.target) && 
      event.target !== hamburger) {
    toggleMenu();
  }
});

// Close menu on escape key
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    const menu = document.getElementById('mobileMenu');
    if (menu.classList.contains('open')) {
      toggleMenu();
    }
  }
});

// Prevent background scrolling when menu is open
document.addEventListener('touchmove', function(event) {
  const menu = document.getElementById('mobileMenu');
  if (menu.classList.contains('open')) {
    if (!menu.contains(event.target)) {
      event.preventDefault();
    }
  }
}, { passive: false });
</script>

<nav class="navbar">
  <a href="/">Home</a>
  <a href="/pages/match_scouting.html">Match Scouting</a>
  <a href="/pages/pit_scouting.html">Pit Scouting</a>
  <a href="/pages/team_summary.html" class="admin-only">Team Summary</a>
  <a href="/pages/match_simulator.html">Match Simulator</a>
  <a href="/pages/rankings.html" class="admin-only">Rankings</a>
  <a href="/pages/raw_match.html">Raw Match Data</a>
  <a href="/pages/raw_match_edit.html" class="admin-only">Raw Match Data Edit</a>
  <a href="/pages/raw_pit.html">Raw Pit Data</a>
  <a href="/pages/raw_pit_edit.html" class="admin-only">Raw Pit Data Edit</a>
  <a href="/pages/csv_upload.html" class="admin-only">CSV Upload</a>
  <a href="/pages/config_creator.html">Config Creator</a>
  <a href="/pages/admin.html" class="admin-only">User Management</a>
  <a href="/pages/logout.html">Logout</a>
</nav>
<div class="container admin-only">
<div class="container">
  <h1>Team Summary</h1>
  <div class="form-row">
    <label>Team Number</label>
    <div class="form-controls">
      <input id="team" type="number" placeholder="e.g., 4123"/>
      <button id="go" class="btn">Load</button>
    </div>
<div class="form-row">
  <label>Match Type Filter</label>
  <div class="form-controls">
    <select id="matchTypeFilter">
      <option value="all">All Matches</option>
      <option value="Practice">Practice</option>
      <option value="Qualification">Qualification</option>
      <option value="Semifinal">Semifinal</option>
      <option value="Final">Final</option>
    </select>
  </div>
  <div class="form-row">
  <label>Event Code Filter</label>
  <div class="form-controls">
    <select id="eventCodeFilter">
      <option value="all">All Events</option>
    </select>
  </div>
</div>
</div>
  </div>
  <div id="teamInfo" class="card" style="display: none;">
    <h3>Team Information</h3>
    <div id="teamInfoContent"></div>
  </div>
<div id="teamStats" class="card" style="display: none;">
  <h3>Team Stats</h3>
  <div id="teamStatsContent"></div>
  <div id="matchTypeStats" style="margin-top: 15px; display: none;">
    <h4>Stats by Match Type</h4>
    <div id="matchTypeStatsContent"></div>
  </div>
</div>
  <div id="summary" class="card"></div>
  
  <div id="robotImageContainer" class="card" style="display: none;">
    <h3>Robot Image</h3>
    <div id="robotImage" class="robot-image-centered"></div>
  </div>
  <div id="chartsContainer"></div>
  <div id="tablesContainer"></div>
</div>
</div>
<footer>FRC 4123 Scouting • Conrad Oldoerp</footer>

<script>
let currentEventCodeFilter = 'all';
let uniqueEventCodes = [];
/**
 * Waits for the authentication module to be fully initialized before proceeding.
 * This ensures auth checks don't run before the auth system is ready.
 */
function waitForAuth() {
    return new Promise((resolve) => {
        if (window.auth && window.auth.isInitialized) {
            resolve();
        } else {
            setTimeout(() => waitForAuth().then(resolve), 100);
        }
    });
}

/**
 * Checks if the user is authenticated and has admin privileges.
 * Redirects to login if not authenticated, shows access denied if not admin.
 */
async function checkAuth() {
    await waitForAuth();
    if (!auth.isLoggedIn()) {
        const currentPath = encodeURIComponent(window.location.pathname + window.location.search);
        window.location.href = `/login.html?redirect=${currentPath}`;
        return false;
    }
    if (!auth.isAdmin()) {
        document.body.innerHTML = `
            <div class="container">
                <h2>Access Denied</h2>
                <p>You need administrator privileges to access the Team Summary page.</p>
                <a href="/">Return to Home</a>
            </div>
        `;
        return false;
    }
    
    return true;
}

/**
 * Retrieves authentication headers for API requests using the stored token.
 */
function getAuthHeaders() {
    const token = localStorage.getItem('authToken');
    return token ? { 'Authorization': token } : {};
}

let charts = {};
let config = null;
let allProcessedData = [];
let currentMatchTypeFilter = 'all';

/**
 * Safely retrieves nested values from an object using dot notation path.
 * Returns 0 if any part of the path is undefined.
 */
function getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
        return current && current[key] !== undefined ? current[key] : 0;
    }, obj);
}

// JavaScript equivalents of SQL functions
const sqlFunctions = {
    ROUND: (value, precision = 0) => {
        const multiplier = Math.pow(10, precision);
        return Math.round(value * multiplier) / multiplier;
    },
    COALESCE: (...args) => {
        for (let arg of args) {
            if (arg !== null && arg !== undefined && !Number.isNaN(arg)) {
                return arg;
            }
        }
        return 0;
    }
};

/**
 * Replaces SQL function calls in expressions with JavaScript equivalents.
 * Handles ROUND and COALESCE functions specifically.
 */
function replaceSqlFunctions(expression) {
    expression = expression.replace(/ROUND\(([^,)]+),\s*([^)]+)\)/g, (match, value, precision) => {
        return `sqlFunctions.ROUND(${value}, ${precision})`;
    });
    expression = expression.replace(/ROUND\(([^)]+)\)/g, (match, value) => {
        return `sqlFunctions.ROUND(${value})`;
    });
    expression = expression.replace(/COALESCE\(([^)]+)\)/g, (match, args) => {
        return `sqlFunctions.COALESCE(${args})`;
    });
    return expression;
}

/**
 * Safely parses JSON strings or returns objects as-is.
 * Handles cases where input might already be parsed or invalid JSON.
 */
function parseMaybeJSON(v) {
    if (v == null) return {};
    if (typeof v === 'string') {
        try { return JSON.parse(v); } catch (e) { console.warn('parse error', e, v); return {}; }
    }
    if (typeof v === 'object') return v;
    return {};
}

/**
 * Calculates computed field values based on configuration formulas.
 * Handles complex expressions, SQL functions, and field dependencies.
 */
function calculateField(row, fieldName, computedFields, processedRow = null) {
    const formula = computedFields[fieldName];
    if (!formula) return 0;
    const preMatch = parseMaybeJSON(row.pre_match_json);
    const auto = parseMaybeJSON(row.auto_json);
    const teleop = parseMaybeJSON(row.teleop_json);
    const endgame = parseMaybeJSON(row.endgame_json);
    const misc = parseMaybeJSON(row.misc_json);
    const config = window.config || {};
    const autoValues = config.match_form?.auto_period || {};
    const teleopValues = config.match_form?.teleop_period || {};
    if (fieldName === 'left_starting_zone') {
        const auto = parseMaybeJSON(row.auto_json);
        const leftStartingZone = getNestedValue(auto, 'left_starting_zone');
        if (typeof leftStartingZone === 'boolean') {
            const configValue = getNestedValue(config, 'match_form.auto_period.left_starting_zone.Value');
            if (configValue !== undefined) {
                return leftStartingZone ? configValue : 0;
            }
        }
        return leftStartingZone ? 3 : 0;
    }
    if (formula.startsWith('json_extract(pre_match_json,')) {
        const fieldMatch = formula.match(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/);
        if (fieldMatch) {
            const value = getNestedValue(preMatch, fieldMatch[1]);
            return value;
        }
    }
    if (formula.startsWith('json_extract(') && !formula.includes('+') && !formula.includes('*') && !formula.includes('CASE')) {
        if (formula.includes('pre_match_json')) {
            const fieldMatch = formula.match(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(preMatch, fieldMatch[1]);
        }
        if (formula.includes('auto_json')) {
            const fieldMatch = formula.match(/json_extract\(auto_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(auto, fieldMatch[1]) || 0;
        }
        if (formula.includes('teleop_json')) {
            const fieldMatch = formula.match(/json_extract\(teleop_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(teleop, fieldMatch[1]) || 0;
        }
        if (formula.includes('endgame_json')) {
            const fieldMatch = formula.match(/json_extract\(endgame_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(endgame, fieldMatch[1]) || 0;
        }
        if (formula.includes('misc_json')) {
            const fieldMatch = formula.match(/json_extract\(misc_json,\s*'\$\.([^']+)'\)/);
            if (fieldMatch) return getNestedValue(misc, fieldMatch[1]) || 0;
        }
    }
    if (formula.includes('CASE json_extract(endgame_json') && formula.includes('final_status')) {
        const finalStatus = getNestedValue(endgame, 'final_status');
        const statusValues = {
            'Park': 2,
            'Failed Climb': 2,
            'Shallow Climb': 6,
            'Deep Climb': 12
        };
        const value = statusValues[finalStatus] || 0;
        return value;
    }
    let result = formula;
    result = result.replace(/config\('([^']+)'\)/g, (match, configPath) => {
        const value = getNestedValue(config, configPath);
        return value !== undefined ? value : 0;
    });
    result = result.replace(/json_extract\(pre_match_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(preMatch, field);
        return typeof value === 'string' ? `"${value}"` : (value || 0);
    });
    result = result.replace(/json_extract\(auto_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(auto, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(teleop_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(teleop, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(endgame_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(endgame, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(misc_json,\s*'\$\.([^']+)'\)/g, (match, field) => {
        const value = getNestedValue(misc, field) || 0;
        return value;
    });
    result = result.replace(/json_extract\(auto_json,\s*'\$\.([^.]+)\.Value'\)/g, (match, field) => {
        let value = 0;
        if (config.match_form?.auto_period?.[field]?.Value !== undefined) {
            value = config.match_form.auto_period[field].Value;
        }
        return value;
    });
    result = result.replace(/json_extract\(teleop_json,\s*'\$\.([^.]+)\.Value'\)/g, (match, field) => {
        let value = 0;
        if (config.match_form?.teleop_period?.[field]?.Value !== undefined) {
            value = config.match_form.teleop_period[field].Value;
        }
        return value;
    });
    if (processedRow) {
        for (const key in processedRow) {
            if (processedRow.hasOwnProperty(key) && result.includes(key)) {
                result = result.replace(new RegExp(`\\b${key}\\b`, 'g'), processedRow[key]);
            }
        }
    }
    const fieldPattern = /\b([a-zA-Z_][a-zA-Z0-9_]*)\b/g;
    const fieldsToReplace = [];
    let match;
    while ((match = fieldPattern.exec(result)) !== null) {
        const fieldRef = match[1];
        if (computedFields[fieldRef] && fieldRef !== fieldName && 
            !['CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'ROUND', 'COALESCE', 'sqlFunctions', 'config'].includes(fieldRef)) {
            fieldsToReplace.push(fieldRef);
        }
    }
    for (const fieldRef of fieldsToReplace) {
        const fieldValue = calculateField(row, fieldRef, computedFields, processedRow);
        result = result.replace(new RegExp(`\\b${fieldRef}\\b`, 'g'), fieldValue);
    }
    result = replaceSqlFunctions(result);
    if (result.includes('CASE WHEN') && result.includes('THEN') && result.includes('ELSE')) {
        try {
            const casePattern = /CASE WHEN\s+(.+?)\s+THEN\s+(.+?)\s+ELSE\s+(.+?)\s+END/;
            const caseMatch = result.match(casePattern);
            if (caseMatch) {
                const conditionExpr = caseMatch[1].trim();
                const thenExpr = caseMatch[2].trim();
                const elseExpr = caseMatch[3].trim();
                const condition = eval(conditionExpr);
                const finalValue = condition ? eval(thenExpr) : eval(elseExpr);
                
                return finalValue;
            }
        } catch (e) {
            console.warn('Failed to evaluate CASE statement:', result, e);
            return 0;
        }
    }
    try {
        const finalValue = eval(result);
        return finalValue || 0;
    } catch (e) {
        console.warn('Failed to evaluate formula:', result, e);
        return 0;
    }
}

/**
 * Extracts unique event codes from processed data
 */
function extractUniqueEventCodes(processedData) {
    const eventCodes = new Set();
    processedData.forEach(match => {
        const eventCode = match.event_code || (match.pre_match_json && match.pre_match_json.event_code) || 'Unknown';
        if (eventCode && eventCode !== 'Unknown') {
            eventCodes.add(eventCode);
        }
    });
    return Array.from(eventCodes).sort();
}

/**
 * Populates the event code filter dropdown
 */
function populateEventCodeFilter(eventCodes) {
    const filter = document.getElementById('eventCodeFilter');
    // Keep the "All Events" option
    const allOption = filter.querySelector('option[value="all"]');
    filter.innerHTML = '';
    filter.appendChild(allOption);
    
    eventCodes.forEach(code => {
        const option = document.createElement('option');
        option.value = code;
        option.textContent = code;
        filter.appendChild(option);
    });
}

/**
 * Filters data based on both match type and event code
 */
function filterData(processedData, matchTypeFilter, eventCodeFilter) {
    return processedData.filter(match => {
        // Match type filter
        const matchTypeMatch = matchTypeFilter === 'all' || match.match_type === matchTypeFilter;
        
        // Event code filter
        const eventCode = match.event_code || (match.pre_match_json && match.pre_match_json.event_code) || 'Unknown';
        const eventCodeMatch = eventCodeFilter === 'all' || eventCode === eventCodeFilter;
        
        return matchTypeMatch && eventCodeMatch;
    });
}

/**
 * Creates a Chart.js chart based on configuration and processed data.
 * Handles both single and multiple dataset configurations.
 */
function createChart(chartName, chartConfig, processedData) {
    const canvasId = `chart_${chartName.replace(/\s+/g, '_')}_${Date.now()}`;
    const canvas = document.createElement('canvas');
    canvas.id = canvasId;
    canvas.width = 400;
    canvas.height = 300;
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<h3>${chartName}</h3>`;
    card.appendChild(canvas);
    const ctx = canvas.getContext('2d')
    const labels = processedData.map(row => row[chartConfig.x] || 'N/A');
    let datasets = [];
    if (Array.isArray(chartConfig.y)) {
        const colors = [
            'rgba(255, 99, 132, 0.7)',
            'rgba(54, 162, 235, 0.7)',
            'rgba(255, 205, 86, 0.7)',
            'rgba(75, 192, 192, 0.7)',
            'rgba(153, 102, 255, 0.7)',
            'rgba(255, 159, 64, 0.7)'
        ];
        chartConfig.y.forEach((yField, index) => {
            datasets.push({
                label: yField.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                data: processedData.map(row => row[yField] || 0),
                backgroundColor: colors[index % colors.length],
                borderColor: colors[index % colors.length].replace('0.7', '1'),
                borderWidth: 2,
                fill: false
            });
        });
    } else {
        datasets.push({
            label: chartConfig.y.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            data: processedData.map(row => row[chartConfig.y] || 0),
            backgroundColor: chartConfig.backgroundColor || 'rgba(153, 102, 255, 0.2)',
            borderColor: chartConfig.borderColor || 'rgba(153, 102, 255, 1)',
            borderWidth: 2,
            fill: true,
            tension: 0.1
        });
    }
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: chartConfig.y_label || 'Value'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: chartConfig.x_label || 'Match'
                    }
                }
            },
            layout: {
                padding: 10
            }
        }
    });
    charts[canvasId] = chart;
    return card;
}

/**
 * Creates a data table based on configuration and processed data.
 * Displays specified columns in a tabular format.
 */
function createTable(tableName, tableConfig, processedData) {
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<h3>${tableName}</h3>`;
    const table = document.createElement('table');
    table.className = 'table';
    const thead = document.createElement('tr');
    tableConfig.columns.forEach(colName => {
        const th = document.createElement('th');
        th.textContent = colName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        thead.appendChild(th);
    });
    table.appendChild(thead);
    processedData.forEach(row => {
        const tr = document.createElement('tr');
        tableConfig.columns.forEach(colName => {
            const td = document.createElement('td');
            const value = row[colName];
            td.textContent = value !== undefined ? value : 'N/A';
            tr.appendChild(td);
        });
        table.appendChild(tr);
    });
    card.appendChild(table);
    return card;
}

/**
 * Loads team information from external API and displays it.
 * Fetches team name, EPA, and ranking data based on configuration.
 */
async function loadTeamInfo(team, config) {
    const teamInfoContainer = document.getElementById('teamInfo');
    const teamInfoContent = document.getElementById('teamInfoContent');
    const teamStatsContainer = document.getElementById('teamStats');
    const teamStatsContent = document.getElementById('teamStatsContent');
    teamInfoContainer.style.display = 'none';
    teamStatsContainer.style.display = 'none';
    teamInfoContent.innerHTML = '';
    teamStatsContent.innerHTML = '';
    //console.log('Full config:', config);
    try {
        let teamInfoConfig = null;
        if (config?.team_summary?.team_info) {
            teamInfoConfig = config.team_summary.team_info;
        } else if (config?.team_info) {
            teamInfoConfig = config.team_info;
        } else if (config?.team_summary) {
            teamInfoConfig = config.team_summary;
        }
        console.log('Team info config found:', teamInfoConfig);
        if (!teamInfoConfig) {
            console.warn('No team info configuration found in config');
            return;
        }
        const shouldFetch = Object.values(teamInfoConfig).some(val => val === true && 
            typeof val === 'boolean' && 
            !['year'].includes(Object.keys(teamInfoConfig)[Object.values(teamInfoConfig).indexOf(val)]));
        
        console.log('Should fetch team info:', shouldFetch);
        if (!shouldFetch) {
            return;
        }
        const year = teamInfoConfig.year || 2025;
        console.log('Fetching team info for year:', year);
        const response = await fetch(`/api/team/${team}/info?year=${year}`, {
            headers: getAuthHeaders()
        });
        const data = await response.json();
        console.log('Team info API response:', data);
        if (data.error) {
            console.warn('Team info API error:', data.error);
            return;
        }
        let infoHtml = '<div class="team-info-grid">';
        let hasInfo = false;
        if (teamInfoConfig.get_team_name && data.name) {
            infoHtml += `<div class="info-item"><strong>Team Name:</strong> ${data.name}</div>`;
            hasInfo = true;
        }
        infoHtml += '</div>';
        if (hasInfo) {
            teamInfoContent.innerHTML = infoHtml;
            teamInfoContainer.style.display = 'block';
        }
        let statsHtml = '<div class="team-stats-grid">';
        let hasStats = false;
        if (teamInfoConfig.get_team_epa && data.epa !== null && data.epa !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.epa.toFixed(1)}</div>
                    <div class="stat-label">EPA</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_state && data.state_rank !== null && data.state_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.state_rank}/${data.state_total || '?'}</div>
                    <div class="stat-label">State Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_country && data.country_rank !== null && data.country_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.country_rank}/${data.country_total || '?'}</div>
                    <div class="stat-label">Country Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_world && data.world_rank !== null && data.world_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.world_rank}/${data.world_total || '?'}</div>
                    <div class="stat-label">World Rank</div>
                </div>
            `;
            hasStats = true;
        }
        if (teamInfoConfig.get_team_rank_in_district && data.district_rank !== null && data.district_rank !== undefined) {
            statsHtml += `
                <div class="stat-item">
                    <div class="stat-value">${data.district_rank}/${data.district_total || '?'}</div>
                    <div class="stat-label">District Rank</div>
                </div>
            `;
            hasStats = true;
        }
        statsHtml += '</div>';
        if (hasStats) {
            teamStatsContent.innerHTML = statsHtml;
            teamStatsContainer.style.display = 'block';
        }
    } catch (error) {
        console.error('Error loading team info:', error);
    }
}

/**
 * Calculates and displays statistics grouped by match type.
 * Shows average scores for each match type category.
 */
function displayMatchTypeStats(processedData) {
    const matchTypeStatsContainer = document.getElementById('matchTypeStats');
    const matchTypeStatsContent = document.getElementById('matchTypeStatsContent');
    if (!processedData.length) {
        matchTypeStatsContainer.style.display = 'none';
        return;
    }
    const matchTypes = {};
    processedData.forEach(match => {
        const type = match.match_type || 'Unknown';
        if (!matchTypes[type]) {
            matchTypes[type] = {
                count: 0,
                totalAuto: 0,
                totalTeleop: 0,
                totalEndgame: 0,
                totalPoints: 0
            };
        }
        matchTypes[type].count++;
        matchTypes[type].totalAuto += match.auto_points || 0;
        matchTypes[type].totalTeleop += match.teleop_points || 0;
        matchTypes[type].totalEndgame += match.endgame_points || 0;
        matchTypes[type].totalPoints += match.total_points || 0;
    });
    let statsHtml = '<div class="match-type-stats-grid">';
    for (const [type, stats] of Object.entries(matchTypes)) {
        const avgAuto = stats.count > 0 ? stats.totalAuto / stats.count : 0;
        const avgTeleop = stats.count > 0 ? stats.totalTeleop / stats.count : 0;
        const avgEndgame = stats.count > 0 ? stats.totalEndgame / stats.count : 0;
        const avgTotal = stats.count > 0 ? stats.totalPoints / stats.count : 0;
        statsHtml += `
            <div class="match-type-stat-item">
                <div class="match-type-stat-label">${type}</div>
                <div class="match-type-stat-count">${stats.count} matches</div>
                <div class="match-type-stat-value">${avgTotal.toFixed(1)}</div>
                <div>Total Points</div>
                <div style="font-size: 0.8rem; margin-top: 5px;">
                    Auto: ${avgAuto.toFixed(1)} | Teleop: ${avgTeleop.toFixed(1)} | Endgame: ${avgEndgame.toFixed(1)}
                </div>
            </div>
        `;
    }
    statsHtml += '</div>';
    matchTypeStatsContent.innerHTML = statsHtml;
    matchTypeStatsContainer.style.display = 'block';
}

/**
 * Main function to load and display team data, charts, and statistics.
 * Orchestrates the entire data loading and visualization process.
 */
async function loadTeam(){
    const isAuthenticated = await checkAuth();
    if (!isAuthenticated) return;
    const team = document.getElementById('team').value;
    if (!team) return;
    currentMatchTypeFilter = document.getElementById('matchTypeFilter').value;
    currentEventCodeFilter = document.getElementById('eventCodeFilter').value;
    try {
        const configResp = await fetch('/api/config').then(r => r.json());
        config = configResp;
        window.config = configResp;
        await loadTeamInfo(team, configResp);
        const [avgResp, rowsResp] = await Promise.all([
            fetch(`/api/team/${team}/averages`, {
                headers: getAuthHeaders()
            }).then(r => r.json()),
            fetch(`/api/team/${team}/matches`, {
                headers: getAuthHeaders()
            }).then(r => r.json())
        ]);
        if (avgResp.error) {
            document.getElementById('summary').innerHTML = `Error: ${avgResp.error}`;
            return;
        }
        const s = document.getElementById('summary');
        s.innerHTML = `
            <h3>Team ${team} Summary</h3>
            <div class="score-row">
                <span>Matches: <strong>${avgResp.matches}</strong></span>
                <span>Avg Auto: <strong>${avgResp.avg_auto.toFixed(2)}</strong></span>
                <span>Avg Teleop: <strong>${avgResp.avg_teleop.toFixed(2)}</strong></span>
                <span>Avg Endgame: <strong>${avgResp.avg_endgame.toFixed(2)}</strong></span>
                <span>Avg Total: <strong>${avgResp.avg_total.toFixed(2)}</strong></span>
            </div>
        `;
        let teamPitData = null;
        try {
            teamPitData = await fetch(`/api/team/${team}/pit`, {
                headers: getAuthHeaders()
            }).then(r => r.json());
        } catch (e) {
            console.log('Could not load pit data:', e);
        }
        const imageContainer = document.getElementById('robotImageContainer');
        const robotImageDiv = document.getElementById('robotImage');
        if (teamPitData && teamPitData.pit_json && teamPitData.pit_json.image_upload) {
            imageContainer.style.display = 'block';
            robotImageDiv.innerHTML = `<img src="${teamPitData.pit_json.image_upload}" style="max-width: 100%; max-height: 400px;" alt="Robot Image">`;
        } else {
            imageContainer.style.display = 'none';
        }
        Object.values(charts).forEach(chart => {
            if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
            }
        });
        charts = {};
        document.getElementById('chartsContainer').innerHTML = '';
        document.getElementById('tablesContainer').innerHTML = '';
        const teamSummaryConfig = config.team_summary;
        const computedFields = teamSummaryConfig.computed_fields || {};
        allProcessedData = rowsResp.map(row => {
            const pre = parseMaybeJSON(row.pre_match_json);
            const processed = {
                match_number: pre.match_number,
                match_type: pre.match_type || 'Unknown',
                event_code: pre.event_code || 'Unknown',
                team_color: pre.team_color,
                auto_points: row.auto_points,
                teleop_points: row.teleop_points,
                endgame_points: row.endgame_points,
                total_points: row.total_points,
                created_at: row.created_at
            };
            for (const fieldName of Object.keys(computedFields)) {
                try {
                    if (!computedFields[fieldName].includes('auto_L') && 
                        !computedFields[fieldName].includes('teleop_L') &&
                        !computedFields[fieldName].includes('CASE WHEN')) {
                        processed[fieldName] = calculateField(row, fieldName, computedFields, processed);
                    }
                } catch (e) {
                    console.warn('compute failed for', fieldName, e);
                    processed[fieldName] = 0;
                }
            }
            for (const fieldName of Object.keys(computedFields)) {
                try {
                    if (computedFields[fieldName].includes('auto_L') || 
                        computedFields[fieldName].includes('teleop_L') ||
                        computedFields[fieldName].includes('CASE WHEN')) {
                        processed[fieldName] = calculateField(row, fieldName, computedFields, processed);
                    }
                } catch (e) {
                    console.warn('compute failed for', fieldName, e);
                    processed[fieldName] = 0;
                }
            }
            return processed;
        });
        uniqueEventCodes = extractUniqueEventCodes(allProcessedData);
        populateEventCodeFilter(uniqueEventCodes);
        const matchTypeOrder = {
            'Practice': 1,
            'Qualification': 2,
            'Semifinal': 3,
            'Final': 4,
            'Unknown': 5
        };
        allProcessedData.sort((a, b) => {
            const typeA = a.match_type || 'Unknown';
            const typeB = b.match_type || 'Unknown';
            if (matchTypeOrder[typeA] !== matchTypeOrder[typeB]) {
                return matchTypeOrder[typeA] - matchTypeOrder[typeB];
            }
            if (a.match_number && b.match_number) {
                return a.match_number - b.match_number;
            }
            return new Date(a.created_at) - new Date(b.created_at);
        });
        const filteredData = filterData(
            allProcessedData, 
            currentMatchTypeFilter, 
            currentEventCodeFilter
        );
        displayMatchTypeStats(allProcessedData);
        if (teamSummaryConfig.body.charts) {
            const chartEntries = Object.entries(teamSummaryConfig.body.charts);
            const container = document.getElementById('chartsContainer');
            const chartPairs = [
                ['Auto Coral Performance', 'Teleop Coral Performance'],
                ['Auto Coral Accuracy', 'Teleop Coral Accuracy']
            ];
            const usedCharts = new Set();
            chartPairs.forEach(pair => {
                const [chart1Name, chart2Name] = pair;
                const chart1Entry = chartEntries.find(([name]) => name === chart1Name);
                const chart2Entry = chartEntries.find(([name]) => name === chart2Name);
                if (chart1Entry && chart2Entry) {
                    const row = document.createElement('div');
                    row.className = 'charts-row';
                    const container1 = document.createElement('div');
                    container1.className = 'chart-container';
                    const card1 = createChart(chart1Entry[0], chart1Entry[1], filteredData);
                    container1.appendChild(card1);
                    const container2 = document.createElement('div');
                    container2.className = 'chart-container';
                    const card2 = createChart(chart2Entry[0], chart2Entry[1], filteredData);
                    container2.appendChild(card2);
                    row.appendChild(container1);
                    row.appendChild(container2);
                    container.appendChild(row);
                    usedCharts.add(chart1Name);
                    usedCharts.add(chart2Name);
                }
            });
            chartEntries.forEach(([chartName, chartConfig]) => {
                if (!usedCharts.has(chartName)) {
                    const row = document.createElement('div');
                    row.className = 'charts-row';
                    const container1 = document.createElement('div');
                    container1.className = 'chart-container';
                    const card = createChart(chartName, chartConfig, filteredData);
                    container1.appendChild(card);
                    row.appendChild(container1);
                    container.appendChild(row);
                }
            });
        }
        if (teamSummaryConfig.body.tables && teamSummaryConfig.body.tables.table) {
            const tablesContainer = document.getElementById('tablesContainer');
            Object.entries(teamSummaryConfig.body.tables.table).forEach(([tableName, tableConfig]) => {
                const displayName = tableName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const tableCard = createTable(displayName, tableConfig, filteredData);
                tablesContainer.appendChild(tableCard);
            });
        }
    } catch (error) {
        console.error('Error loading team data:', error);
        document.getElementById('summary').innerHTML = 'Error loading team data. Please try again.';
    }
}

// Event listeners
document.getElementById('go').addEventListener('click', loadTeam);

// Load on Enter key in team input
document.getElementById('team').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') loadTeam();
});

// Add event listener for the match type filter
document.getElementById('matchTypeFilter').addEventListener('change', function() {
    if (document.getElementById('team').value) {
        loadTeam();
    }
});

// Add event listener for the event code filter
document.getElementById('eventCodeFilter').addEventListener('change', function() {
    if (document.getElementById('team').value) {
        loadTeam();
    }
});

// Check authentication when page loads
document.addEventListener('DOMContentLoaded', async () => {
    await checkAuth();
});
</script>

</body></html>